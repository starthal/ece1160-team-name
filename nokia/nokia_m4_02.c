/*
 * This file is part of the libopencm3 project.
 *
 * Copyright (C) 2011 Fergus Noble <fergusnoble@gmail.com>
 * Copyright (C) 2011 Henry Hallam <henry@pericynthion.org>
 *
 * This library is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this library.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <stdio.h>
#include <errno.h>
#include <libopencm3/stm32/spi.h>
#include <libopencm3/stm32/usart.h>
#include <libopencm3/stm32/nvic.h>
#include <libopencm3/stm32/f2/gpio.h>
#include <libopencm3/stm32/f2/rcc.h>
#include <libopencm3/stm32/timer.h>
#include "nokia.h"

// *********************************************************************************
//
//       Font tables for Nokia 6610 LCD Display Driver (S1D15G00 Controller)
//
//                FONT6x8 - SMALL font (mostly 5x7)
//                FONT8x8 - MEDIUM font (8x8 characters, a bit thicker)
//                FONT8x16 - LARGE font (8x16 characters, thicker)
//
//                Note: ASCII characters 0x00 through 0x1F are not included in these fonts.
//
// Author: Jim Parise, James P Lynch August 30, 2007
// *********************************************************************************
const unsigned char FONT6x8[97][8] = {
{0x06,0x08,0x08,0x00,0x00,0x00,0x00,0x00},   //   columns, rows, num_bytes_per_char
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //        space    0x20
0x20,0x20,0x20,0x20,0x20,0x00,0x20,0x00,   //        !
0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00,   //        "
0x50,0x50,0xF8,0x50,0xF8,0x50,0x50,0x00,   //        #
0x20,0x78,0xA0,0x70,0x28,0xF0,0x20,0x00,   //        $
0xC0,0xC8,0x10,0x20,0x40,0x98,0x18,0x00,   //        %
0x40,0xA0,0xA0,0x40,0xA8,0x90,0x68,0x00,   //        &
0x30,0x30,0x20,0x40,0x00,0x00,0x00,0x00,   //        '
0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00,   //        (
0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00,   //        )
0x00,0x20,0xA8,0x70,0x70,0xA8,0x20,0x00,   //        *
0x00,0x20,0x20,0xF8,0x20,0x20,0x00,0x00,   //        +
0x00,0x00,0x00,0x00,0x30,0x30,0x20,0x40,   //        ,
0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,   //        -
0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,   //        .
0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,   //        / (forward slash)
0x70,0x88,0x88,0xA8,0x88,0x88,0x70,0x00,   //        0                 0x30
0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00,   //        1
0x70,0x88,0x08,0x70,0x80,0x80,0xF8,0x00,   //        2
0xF8,0x08,0x10,0x30,0x08,0x88,0x70,0x00,   //        3
0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00,   //        4
0xF8,0x80,0xF0,0x08,0x08,0x88,0x70,0x00,   //        5
0x38,0x40,0x80,0xF0,0x88,0x88,0x70,0x00,   //        6
0xF8,0x08,0x08,0x10,0x20,0x40,0x80,0x00,   //        7
0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x00,   //        8
0x70,0x88,0x88,0x78,0x08,0x10,0xE0,0x00,   //        9
0x00,0x00,0x20,0x00,0x20,0x00,0x00,0x00,   //        :
0x00,0x00,0x20,0x00,0x20,0x20,0x40,0x00,   //        ;
0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00,   //        <
0x00,0x00,0xF8,0x00,0xF8,0x00,0x00,0x00,   //        =
0x40,0x20,0x10,0x08,0x10,0x20,0x40,0x00,   //        >
0x70,0x88,0x08,0x30,0x20,0x00,0x20,0x00,   //        ?
0x70,0x88,0xA8,0xB8,0xB0,0x80,0x78,0x00,   //        @                 0x40
0x20,0x50,0x88,0x88,0xF8,0x88,0x88,0x00,   //        A
0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00,   //        B
0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00,   //        C
0xF0,0x88,0x88,0x88,0x88,0x88,0xF0,0x00,   //        D
0xF8,0x80,0x80,0xF0,0x80,0x80,0xF8,0x00,   //        E
0xF8,0x80,0x80,0xF0,0x80,0x80,0x80,0x00,   //        F
0x78,0x88,0x80,0x80,0x98,0x88,0x78,0x00,   //        G
0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00,   //        H
0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00,   //        I
0x38,0x10,0x10,0x10,0x10,0x90,0x60,0x00,   //        J
0x88,0x90,0xA0,0xC0,0xA0,0x90,0x88,0x00,   //        K
0x80,0x80,0x80,0x80,0x80,0x80,0xF8,0x00,   //        L
0x88,0xD8,0xA8,0xA8,0xA8,0x88,0x88,0x00,   //        M
0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00,   //        N
0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00,   //        O
0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00,   //        P                 0x50
0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00,   //        Q
0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00,   //        R
0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00,   //        S
0xF8,0xA8,0x20,0x20,0x20,0x20,0x20,0x00,   //        T
0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00,   //        U
0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00,   //        V
0x88,0x88,0x88,0xA8,0xA8,0xA8,0x50,0x00,    //       W
0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00,    //       X
0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00,    //       Y
0xF8,0x08,0x10,0x70,0x40,0x80,0xF8,0x00,    //       Z
0x78,0x40,0x40,0x40,0x40,0x40,0x78,0x00,    //       [
0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,    //       \ (back slash)
0x78,0x08,0x08,0x08,0x08,0x08,0x78,0x00,    //       ]
0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00,    //       ^
0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x00,    //       _
0x60,0x60,0x20,0x10,0x00,0x00,0x00,0x00,    //       `                0x60
0x00,0x00,0x60,0x10,0x70,0x90,0x78,0x00,    //       a
0x80,0x80,0xB0,0xC8,0x88,0xC8,0xB0,0x00,    //       b
0x00,0x00,0x70,0x88,0x80,0x88,0x70,0x00,    //       c
0x08,0x08,0x68,0x98,0x88,0x98,0x68,0x00,    //       d
0x00,0x00,0x70,0x88,0xF8,0x80,0x70,0x00,    //       e
0x10,0x28,0x20,0x70,0x20,0x20,0x20,0x00,    //       f
0x00,0x00,0x70,0x98,0x98,0x68,0x08,0x70,    //       g
0x80,0x80,0xB0,0xC8,0x88,0x88,0x88,0x00,    //       h
0x20,0x00,0x60,0x20,0x20,0x20,0x70,0x00,    //       i
0x10,0x00,0x10,0x10,0x10,0x90,0x60,0x00,    //       j
0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00,    //       k
0x60,0x20,0x20,0x20,0x20,0x20,0x70,0x00,    //       l
0x00,0x00,0xD0,0xA8,0xA8,0xA8,0xA8,0x00,    //       m
0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00,    //       n
0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00,    //       o
0x00,0x00,0xB0,0xC8,0xC8,0xB0,0x80,0x80,    //       p                0x70
0x00,0x00,0x68,0x98,0x98,0x68,0x08,0x08,    //       q
0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00,    //       r
0x00,0x00,0x78,0x80,0x70,0x08,0xF0,0x00,    //       s
0x20,0x20,0xF8,0x20,0x20,0x28,0x10,0x00,    //       t
0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00,    //       u
0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00,    //       v
0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00,    //       w
0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00,    //       x
0x00,0x00,0x88,0x88,0x78,0x08,0x88,0x70,    //       y
0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00,    //       z
0x10,0x20,0x20,0x40,0x20,0x20,0x10,0x00,    //       {
0x20,0x20,0x20,0x00,0x20,0x20,0x20,0x00,    //       |
0x40,0x20,0x20,0x10,0x20,0x20,0x40,0x00,    //       }
0x40,0xA8,0x10,0x00,0x00,0x00,0x00,0x00,    //       ~
0x70,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00};   //       DEL



const unsigned char FONT8x8[97][8] = {

0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00,    //   columns, rows, num_bytes_per_char
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    //        space    0x20
0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00,    //        !
0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00,    //        "
0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00,    //        #
0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00,    //        $
0x00,0x63,0x66,0x0C,0x18,0x33,0x63,0x00,    //        %
0x1C,0x36,0x1C,0x3B,0x6E,0x66,0x3B,0x00,    //        &
0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,    //        '
0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00,    //        (
0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00,    //        )
0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,    //        *
0x00,0x30,0x30,0xFC,0x30,0x30,0x00,0x00,    //        +
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30,    //        ,
0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,    //        -
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,    //        .
0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00,    //        / (forward slash)
0x3E,0x63,0x63,0x6B,0x63,0x63,0x3E,0x00,    //        0                 0x30
0x18,0x38,0x58,0x18,0x18,0x18,0x7E,0x00,    //        1
0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00,    //        2
0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00,    //        3
0x0E,0x1E,0x36,0x66,0x7F,0x06,0x0F,0x00,    //        4
0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00,    //        5
0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00,    //        6
0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00,    //        7
0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00,    //        8
0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00,    //        9
0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,    //        :
0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30,    //        ;
0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00,    //        <
0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,    //        =
0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00,    //        >
0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00,    //        ?
0x3E,0x63,0x6F,0x69,0x6F,0x60,0x3E,0x00,    //        @                 0x40
0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00,    //        A
0x7E,0x33,0x33,0x3E,0x33,0x33,0x7E,0x00,    //        B
0x1E,0x33,0x60,0x60,0x60,0x33,0x1E,0x00,    //        C
0x7C,0x36,0x33,0x33,0x33,0x36,0x7C,0x00,    //     D
0x7F,0x31,0x34,0x3C,0x34,0x31,0x7F,0x00,    //     E
0x7F,0x31,0x34,0x3C,0x34,0x30,0x78,0x00,    //     F
0x1E,0x33,0x60,0x60,0x67,0x33,0x1F,0x00,    //     G
0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,    //     H
0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,    //     I
0x0F,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,    //     J
0x73,0x33,0x36,0x3C,0x36,0x33,0x73,0x00,    //     K
0x78,0x30,0x30,0x30,0x31,0x33,0x7F,0x00,    //     L
0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00,    //     M
0x63,0x73,0x7B,0x6F,0x67,0x63,0x63,0x00,    //     N
0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,    //     O
0x7E,0x33,0x33,0x3E,0x30,0x30,0x78,0x00,    //     P                0x50
0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00,    //     Q
0x7E,0x33,0x33,0x3E,0x36,0x33,0x73,0x00,    //     R
0x3C,0x66,0x30,0x18,0x0C,0x66,0x3C,0x00,    //     S
0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00,    //     T
0x66,0x66,0x66,0x66,0x66,0x66,0x7E,0x00,    //     U
0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,    //     V
0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00,    //     W
0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00,    //     X
0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00,    //     Y
0x7F,0x63,0x46,0x0C,0x19,0x33,0x7F,0x00,    //     Z
0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,    //     [
0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00,    //     \ (back slash)
0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,    //     ]
0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,    //     ^
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,    //     _
0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,    //     `                0x60
0x00,0x00,0x3C,0x06,0x3E,0x66,0x3B,0x00,    //     a
0x70,0x30,0x3E,0x33,0x33,0x33,0x6E,0x00,    //     b
0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00,    //     c
0x0E,0x06,0x3E,0x66,0x66,0x66,0x3B,0x00,    //     d
0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00,    //     e
0x1C,0x36,0x30,0x78,0x30,0x30,0x78,0x00,    //     f
0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x7C,    //     g
0x70,0x30,0x36,0x3B,0x33,0x33,0x73,0x00,    //     h
0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00,    //     i
0x06,0x00,0x06,0x06,0x06,0x66,0x66,0x3C,    //     j
0x70,0x30,0x33,0x36,0x3C,0x36,0x73,0x00,    //     k
0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,    //     l
0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00,    //     m
0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00,    //     n
0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00,    //     o
0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78,    //     p                0x70
0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F,    //     q
0x00,0x00,0x6E,0x3B,0x33,0x30,0x78,0x00,    //     r
0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00,    //     s
0x08,0x18,0x3E,0x18,0x18,0x1A,0x0C,0x00,    //     t
0x00,0x00,0x66,0x66,0x66,0x66,0x3B,0x00,    //     u
0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00,    //     v
0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00,    //     w
0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00,    //     x
0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x7C,    //     y
0x00,0x00,0x7E,0x4C,0x18,0x32,0x7E,0x00,    //     z
0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00,    //     {
0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x0C,0x00,    //     |
0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00,    //     }
0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,    //     ~
0x1C,0x36,0x36,0x1C,0x00,0x00,0x00,0x00};   //     DEL




const unsigned char FONT8x16[97][16] = {

0x08,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //   columns, rows, num_bytes_per_char
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //        space    0x20
0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,   //        !
0x00,0x63,0x63,0x63,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //        "
0x00,0x00,0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00,0x00,0x00,   //        #
0x0C,0x0C,0x3E,0x63,0x61,0x60,0x3E,0x03,0x03,0x43,0x63,0x3E,0x0C,0x0C,0x00,0x00,   //        $
0x00,0x00,0x00,0x00,0x00,0x61,0x63,0x06,0x0C,0x18,0x33,0x63,0x00,0x00,0x00,0x00,   //        %
0x00,0x00,0x00,0x1C,0x36,0x36,0x1C,0x3B,0x6E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,   //        &
0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //        '
0x00,0x00,0x0C,0x18,0x18,0x30,0x30,0x30,0x30,0x18,0x18,0x0C,0x00,0x00,0x00,0x00,   //        (
0x00,0x00,0x18,0x0C,0x0C,0x06,0x06,0x06,0x06,0x0C,0x0C,0x18,0x00,0x00,0x00,0x00,   //        )
0x00,0x00,0x00,0x00,0x42,0x66,0x3C,0xFF,0x3C,0x66,0x42,0x00,0x00,0x00,0x00,0x00,   //        *
0x00,0x00,0x00,0x00,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00,   //        +
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,   //        ,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,   //        -
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,   //        .
0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00,   //        / (forward slash)
0x00,0x00,0x3E,0x63,0x63,0x63,0x6B,0x6B,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,   //        0                 0x30
0x00,0x00,0x0C,0x1C,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x00,0x00,0x00,0x00,   //        1
0x00,0x00,0x3E,0x63,0x03,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00,   //        2
0x00,0x00,0x3E,0x63,0x03,0x03,0x1E,0x03,0x03,0x03,0x63,0x3E,0x00,0x00,0x00,0x00,   //        3
0x00,0x00,0x06,0x0E,0x1E,0x36,0x66,0x66,0x7F,0x06,0x06,0x0F,0x00,0x00,0x00,0x00,    //   4
0x00,0x00,0x7F,0x60,0x60,0x60,0x7E,0x03,0x03,0x63,0x73,0x3E,0x00,0x00,0x00,0x00,    //   5
0x00,0x00,0x1C,0x30,0x60,0x60,0x7E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,    //   6
0x00,0x00,0x7F,0x63,0x03,0x06,0x06,0x0C,0x0C,0x18,0x18,0x18,0x00,0x00,0x00,0x00,    //   7
0x00,0x00,0x3E,0x63,0x63,0x63,0x3E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,    //   8
0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x06,0x3C,0x00,0x00,0x00,0x00,    //   9
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,    //   :
0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,    //   ;
0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00,    //   <
0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,    //   =
0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00,    //   >
0x00,0x00,0x3E,0x63,0x63,0x06,0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x00,0x00,0x00,0x00,    //   ?
0x00,0x00,0x3E,0x63,0x63,0x6F,0x6B,0x6B,0x6E,0x60,0x60,0x3E,0x00,0x00,0x00,0x00,    //   @                0x40
0x00,0x00,0x08,0x1C,0x36,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x00,0x00,0x00,0x00,    //   A
0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x33,0x33,0x33,0x33,0x7E,0x00,0x00,0x00,0x00,    //   B
0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x60,0x60,0x61,0x33,0x1E,0x00,0x00,0x00,0x00,    //   C
0x00,0x00,0x7C,0x36,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x7C,0x00,0x00,0x00,0x00,    //   D
0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00,    //   E
0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,    //   F
0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x6F,0x63,0x63,0x37,0x1D,0x00,0x00,0x00,0x00,    //   G
0x00,0x00,0x63,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00,    //   H
0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,    //   I
0x00,0x00,0x0F,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,    //   J
0x00,0x00,0x73,0x33,0x36,0x36,0x3C,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00,    //   K
0x00,0x00,0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00,    //   L
0x00,0x00,0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00,    //   M
0x00,0x00,0x63,0x63,0x73,0x7B,0x7F,0x6F,0x67,0x63,0x63,0x63,0x00,0x00,0x00,0x00,    //   N
0x00,0x00,0x1C,0x36,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x00,0x00,0x00,0x00,    //   O
0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,    //   P                0x50
0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6F,0x3E,0x06,0x07,0x00,0x00,    //   Q
0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00,    //   R
0x00,0x00,0x3E,0x63,0x63,0x30,0x1C,0x06,0x03,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,    //   S
0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,    //   T
0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,    //   U
0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x08,0x00,0x00,0x00,0x00,    //   V
0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x36,0x00,0x00,0x00,0x00,    //   W
0x00,0x00,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x3C,0x66,0xC3,0xC3,0x00,0x00,0x00,0x00,    //   X
0x00,0x00,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,    //   Y
0x00,0x00,0x7F,0x63,0x43,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00,    //   Z
0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00,    //   [
0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00,    //   \ (back slash)
0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00,    //   ]
0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    //   ^
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,    //   _
0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    //   `                0x60
0x00,0x00,0x00,0x00,0x00,0x3C,0x46,0x06,0x3E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,    //   a
0x00,0x00,0x70,0x30,0x30,0x3C,0x36,0x33,0x33,0x33,0x33,0x6E,0x00,0x00,0x00,0x00,    //   b
0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x60,0x60,0x60,0x63,0x3E,0x00,0x00,0x00,0x00,    //   c
0x00,0x00,0x0E,0x06,0x06,0x1E,0x36,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,    //   d
0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x7E,0x60,0x63,0x3E,0x00,0x00,0x00,0x00,    //   e
0x00,0x00,0x1C,0x36,0x32,0x30,0x7C,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,    //   f
0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00,0x00,    //   g
0x00,0x00,0x70,0x30,0x30,0x36,0x3B,0x33,0x33,0x33,0x33,0x73,0x00,0x00,0x00,0x00,    //   h
0x00,0x00,0x0C,0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,    //   i
0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,    //   j
0x00,0x00,0x70,0x30,0x30,0x33,0x33,0x36,0x3C,0x36,0x33,0x73,0x00,0x00,0x00,0x00,    //   k
0x00,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,    //   l
0x00,0x00,0x00,0x00,0x00,0x6E,0x7F,0x6B,0x6B,0x6B,0x6B,0x6B,0x00,0x00,0x00,0x00,    //   m
0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x33,0x33,0x00,0x00,0x00,0x00,    //   n
0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00,    //   o
0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x3E,0x30,0x30,0x78,0x00,0x00,    //   p                0x70
0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00,0x00,    //   q
0x00,0x00,0x00,0x00,0x00,0x6E,0x3B,0x33,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,    //   r
0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x38,0x0E,0x03,0x63,0x3E,0x00,0x00,0x00,0x00,    //   s
0x00,0x00,0x08,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x1B,0x0E,0x00,0x00,0x00,0x00,    //   t
0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00,    //   u
0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x36,0x36,0x1C,0x1C,0x08,0x00,0x00,0x00,0x00,    //   v
0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x00,0x00,0x00,0x00,    //   w
0x00,0x00,0x00,0x00,0x00,0x63,0x36,0x1C,0x1C,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,    //   x
0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x3F,0x03,0x06,0x3C,0x00,0x00,    //   y
0x00,0x00,0x00,0x00,0x00,0x7F,0x66,0x0C,0x18,0x30,0x63,0x7F,0x00,0x00,0x00,0x00,    //   z
0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00,    //   {
0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,    //   |
0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,    //   }
0x00,0x00,0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,    //   ~
0x00,0x70,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};   //   DEL

volatile int count = 0;
volatile int max_micros = 0;

void tim_setup(void){

	/* Enable TIM2 clock. */
	rcc_peripheral_enable_clock(&RCC_APB1ENR, RCC_APB1ENR_TIM2EN);

	/* Enable TIM2 interrupt. */
	nvic_enable_irq(NVIC_TIM2_IRQ);

	/* Reset TIM2 peripheral. */
	timer_reset(TIM2);

	/* Timer global mode:
	 * - No divider
	 * - Alignment edge
	 * - Direction up
	 */
	timer_set_mode(TIM2, TIM_CR1_CKD_CK_INT,
		       TIM_CR1_CMS_EDGE, TIM_CR1_DIR_UP);

	/* APB1 clock = 30000000 Hz; prescaler = 30; -> tim2 freq. = 1000000 Hz*/
	timer_set_prescaler(TIM2, 30);

	/* Enable preload. */
	timer_disable_preload(TIM2);

	/* Continous mode. */
	timer_continuous_mode(TIM2);

	/* count up to 1 ( 1 microsecond ) */
	timer_set_period(TIM2, 1);

	/* Disable outputs. */
	timer_disable_oc_output(TIM2, TIM_OC1);
	timer_disable_oc_output(TIM2, TIM_OC2);
	timer_disable_oc_output(TIM2, TIM_OC3);
	timer_disable_oc_output(TIM2, TIM_OC4);

	/* -- OC1 configuration -- */

	/* Configure global mode of line 1. */
	timer_disable_oc_clear(TIM2, TIM_OC1);
	timer_disable_oc_preload(TIM2, TIM_OC1);
	timer_set_oc_slow_mode(TIM2, TIM_OC1);
	timer_set_oc_mode(TIM2, TIM_OC1, TIM_OCM_FROZEN);

	/* Set the capture compare value for OC1. */
	timer_set_oc_value(TIM2, TIM_OC1, 1);

	/* ---- */

	/* ARR reload enable. */
	timer_disable_preload(TIM2);

	/* Counter enable. */
	timer_enable_counter(TIM2);

	/* Enable commutation interrupt. */
	timer_enable_irq(TIM2, TIM_DIER_CC1IE);
	
	return;
	}

void tim2_isr(void)
{
	if (timer_get_flag(TIM2, TIM_SR_CC1IF)) {

		/* Clear compare interrupt flag. */
		timer_clear_flag(TIM2, TIM_SR_CC1IF);

		/* compare value = 1 microsecond */
		
		timer_set_oc_value(TIM2, TIM_OC1, 1);
		
		/* count max_micros microseconds, then count = 0. */
		if(count >= 5000000)
			count = 0;
		count++;

	}
}

// delay microseconds
void udelay(int micros){

	max_micros = micros;
	count = 0;
	while(count < micros);

	return;	
	}


void clock_setup(void){

	//Sys Clock
	rcc_clock_setup_hse_3v3(&hse_8mhz_3v3[CLOCK_3V3_120MHZ]);

	//PE 0,1,2,3 For Reset, Data, Clk, Ss
	rcc_peripheral_enable_clock(&RCC_AHB1ENR, RCC_AHB1ENR_IOPEEN);
	gpio_mode_setup(GPIOE, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO0 | GPIO1 | GPIO2 | GPIO3);
	gpio_set_output_options(GPIOE, GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, GPIO0 | GPIO1 | GPIO2 | GPIO3);

	}


//Description: Sends a 9 bit command over SPI to the LCD with
//			   the first bit HIGH indicating "command" mode.
void WriteSpiCommand(unsigned char data){

	char j;
	gpio_clear(GPIOE, GPIO1);
	gpio_clear(GPIOE, GPIO3);

	gpio_set(GPIOE, GPIO2);
	gpio_clear(GPIOE, GPIO2);
	
	for (j = 0; j < 8; j++){

        	if ((data & 0x80) == 0x80) 
			gpio_set(GPIOE, GPIO1);
        	else 
			gpio_clear(GPIOE, GPIO1);;

        gpio_set(GPIOE, GPIO2);
	gpio_clear(GPIOE, GPIO2); //Send clock pulse
        
        data <<= 1;
		}

    	gpio_set(GPIOE, GPIO3);  //Disable chip

	return;
	}


//Description: Sends a 9 bit command over SPI to the LCD with
//			   the first bit LOW indicating "data" mode.
void WriteSpiData(unsigned char data){

	char j;
	
	gpio_clear(GPIOE, GPIO2);
	gpio_clear(GPIOE, GPIO3); //Enable chip   
	gpio_set(GPIOE, GPIO1);   //Output high on data out (9th bit high = data)
        gpio_set(GPIOE, GPIO2);
	gpio_clear(GPIOE, GPIO2); //Send clock
	
	for (j = 0; j < 8; j++){
		if ((data & 0x80) == 0x80) 
			gpio_set(GPIOE, GPIO1);
        	else 
			gpio_clear(GPIOE, GPIO1);
        gpio_set(GPIOE, GPIO2);
	gpio_clear(GPIOE, GPIO2); //Send clock pulse
        
        data <<= 1;
		}

     	gpio_set(GPIOE, GPIO3);  //Disable chip

	return;
	}


void InitLcd(void) {
	
	gpio_set(GPIOE, GPIO3);
	gpio_clear(GPIOE, GPIO2);
	gpio_clear(GPIOE, GPIO1);
	gpio_set(GPIOE, GPIO0);

        // Hardware reset
        gpio_clear(GPIOE, GPIO0);
        udelay(5000);
        gpio_set(GPIOE, GPIO0);
        udelay(50000);

        // Display control
        WriteSpiCommand(DISCTL);
        WriteSpiData(0x00); // P1: 0x00 = 2 divisions, switching period=8 (default)
        WriteSpiData(0x20); // P2: 0x20 = nlines/4 - 1 = 132/4 - 1 = 32)
        WriteSpiData(0x00); // P3: 0x00 = no inversely highlighted lines

        // COM scan
        WriteSpiCommand(COMSCN);
        WriteSpiData(1);         // P1: 0x01 = Scan 1->80, 160<-81

        // Internal oscilator ON
        WriteSpiCommand(OSCON);

        // Sleep out
        WriteSpiCommand(SLPOUT);

        // Power control
        WriteSpiCommand(PWRCTR);
        WriteSpiData(0x0f);   // reference voltage regulator on, circuit voltage follower on, BOOST ON

        // Inverse display
        WriteSpiCommand(DISINV);

        // Data control
        WriteSpiCommand(DATCTL);
        WriteSpiData(0x01); // P1: 0x01 = page address inverted, column address normal, address scan in column direction
        WriteSpiData(0x00); // P2: 0x00 = RGB sequence (default value)
        WriteSpiData(0x02); // P3: 0x02 = Grayscale -> 16 (selects 12-bit color, type A)

        // Voltage control (contrast setting)
        WriteSpiCommand(VOLCTR);
        WriteSpiData(32); // P1 = 32 volume value (experiment with this value to get the best contrast)
        WriteSpiData(3);   // P2 = 3   resistance ratio (only value that works)

        // allow power supply to stabilize
        udelay(100000);

        // turn on the display
        WriteSpiCommand(DISON);

	return;
	}

void LCDClearScreen(void) {

        long i;                          // loop counter

        // Row address set (command 0x2B)
        WriteSpiCommand(PASET);
        WriteSpiData(0);
        WriteSpiData(131);

        // Column address set (command 0x2A)
        WriteSpiCommand(CASET);
        WriteSpiData(0);
        WriteSpiData(131);

        // set the display memory to BLACK
        WriteSpiCommand(RAMWR);
        for(i = 0; i < ((131 * 131) / 2); i++){

 	       WriteSpiData((BLACK >> 4) & 0xFF);
               WriteSpiData(((BLACK & 0xF) << 4) | ((BLACK >> 8) & 0xF));
               WriteSpiData(BLACK & 0xFF);
        
		}
	return;
	}

void LCDSetPixel(int x, int y, int color) {

        // Row address set (command 0x2B)
        WriteSpiCommand(PASET);
        WriteSpiData(x);
        WriteSpiData(x);

        // Column address set (command 0x2A)
        WriteSpiCommand(CASET);
        WriteSpiData(y);
        WriteSpiData(y);

        // Now illuminate the pixel (2nd pixel will be ignored)
        WriteSpiCommand(RAMWR);
        WriteSpiData((color >> 4) & 0xFF);
        WriteSpiData(((color & 0xF) << 4) | ((color >> 8) & 0xF));
        WriteSpiData(color & 0xFF);

	return;
	}


// *************************************************************************************************
//                         LCDSetLine.c
//
//       Draws a line in the specified color from (x0,y0) to (x1,y1)
//
//       Inputs:    x     =   row address (0 .. 131)
//                  y     =   column address (0 .. 131)
//                  color =         12-bit color value rrrrggggbbbb
//                                  rrrr = 1111 full red
//                                           :
//                                  0000 red is off
//
//                                  gggg = 1111 full green
//                                           :
//                                  0000 green is off
//
//                                  bbbb = 1111 full blue
//                                           :
//                                  0000 blue is off
//
//       Returns:   nothing
//
//       Note: good write-up on this algorithm in Wikipedia (search for Bresenham's line algorithm)
//             see lcd.h for some sample color settings
//
//       Authors:          Dr. Leonard McMillan, Associate Professor UNC
//                         Jack Bresenham IBM, Winthrop University (Father of this algorithm, 1962)
//
//       Note: taken verbatim from Professor McMillan's presentation:
//             http://www.cs.unc.edu/~mcmillan/comp136/Lecture6/Lines.html
//
// *************************************************************************************************
void LCDSetLine(int x0, int y0, int x1, int y1, int color) {

	int dy = y1 - y0;
        int dx = x1 - x0;
        int stepx, stepy;
        if(dy < 0){ 
		dy = -dy;       
		stepy = -1; 
		}   
	else{ 
		stepy = 1; 
		}
        if(dx < 0){ 
	dx = -dx;       
	stepx = -1; 
		}   
	else{ 
		stepx = 1; 
		}

        dy <<= 1;	// dy is now   2*dy
        dx <<= 1;       // dx is now   2*dx

        LCDSetPixel(x0, y0, color);
        if(dx > dy){
        	int fraction = dy - (dx >> 1); // same as 2*dy - dx
        while(x0 != x1){
        	if(fraction >= 0){
                	y0 += stepy;
                        fraction -= dx;        // same as fraction -= 2*dx
                 	}
                 x0 += stepx;
                 fraction += dy;             // same as fraction -= 2*dy
                 LCDSetPixel(x0, y0, color);
		}
         }else{
         	int fraction = dx - (dy >> 1);
          	while (y0 != y1) {
                	if (fraction >= 0){
                      		x0 += stepx;
                      		fraction -= dy;
                 	}
                y0 += stepy;
                fraction += dx;
                LCDSetPixel(x0, y0, color);
             		}
         	}
	return;
	}

void LCDSetRect(int x0, int y0, int x1, int y1, unsigned char fill, int color) {
         int xmin, xmax, ymin, ymax;
         int i;

         // check if the rectangle is to be filled
         if(fill == FILL){

         	// best way to create a filled rectangle is to define a drawing box
                // and loop two pixels at a time

                // calculate the min and max for x and y directions
                xmin = (x0 <= x1) ? x0 : x1;
                xmax = (x0 > x1) ? x0 : x1;
                ymin = (y0 <= y1) ? y0 : y1;
                ymax = (y0 > y1) ? y0 : y1;

                // specify the controller drawing box according to those limits
                // Row address set (command 0x2B)
                WriteSpiCommand(PASET);
                WriteSpiData(xmin);
                WriteSpiData(xmax);

                // Column address set (command 0x2A)
                WriteSpiCommand(CASET);
                WriteSpiData(ymin);
                WriteSpiData(ymax);

                // WRITE MEMORY
                WriteSpiCommand(RAMWR);

                // loop on total number of pixels / 2
                for(i = 0; i < ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 130); i++){

                	// use the color value to output three data bytes covering two pixels
                        WriteSpiData((color >> 4) & 0xFF);
                        WriteSpiData(((color & 0xF) << 4) | ((color >> 8) & 0xF));
                        WriteSpiData(color & 0xFF);
                 	}

         }else{

         	// best way to   draw un   unfilled rectangle is to draw four lines
                LCDSetLine(x0,   y0, x1,   y0, color);
                LCDSetLine(x0,   y1, x1,   y1, color);
                LCDSetLine(x0,   y0, x0,   y1, color);
                LCDSetLine(x1,   y0, x1,   y1, color);
     		}
	
	return;
	}

//   *************************************************************************************
//                         LCDSetCircle.c
//
//       Draws a line in the specified color at center (x0,y0) with radius
//
//       Inputs:        x0       =     row address (0 .. 131)
//                      y0       =     column address (0 .. 131)
//                      radius   =    radius in pixels
//                      color    =         12-bit color value rrrrggggbbbb
//
//       Returns:       nothing
//
//       Author: Jack Bresenham IBM, Winthrop University (Father of this algorithm, 1962)
//
//       Note: taken verbatim Wikipedia article on Bresenham's line algorithm
//             http://www.wikipedia.org
//
//   *************************************************************************************

void LCDSetCircle(int x0, int y0, int radius, int color) {
         int f = 1 - radius;
         int ddF_x = 0;
         int ddF_y = -2 * radius;
         int x = 0;
         int y = radius;

         LCDSetPixel(x0, y0 + radius,              color);
         LCDSetPixel(x0, y0 - radius,              color);
         LCDSetPixel(x0 + radius, y0,              color);
         LCDSetPixel(x0 - radius, y0,              color);

         while(x < y) {
                  if(f >= 0) {
                           y--;
                           ddF_y += 2;
                           f += ddF_y;
                  }
                  x++;
                  ddF_x += 2;
                  f += ddF_x + 1;
                  LCDSetPixel(x0 + x, y0             +   y,   color);
                  LCDSetPixel(x0 - x, y0             +   y,   color);
                  LCDSetPixel(x0 + x, y0             -   y,   color);
                  LCDSetPixel(x0 - x, y0             -   y,   color);
                  LCDSetPixel(x0 + y, y0             +   x,   color);
                  LCDSetPixel(x0 - y, y0             +   x,   color);
                  LCDSetPixel(x0 + y, y0             -   x,   color);
                  LCDSetPixel(x0 - y, y0             -   x,   color);
         }

	return;
	}

//   *****************************************************************************
//                         LCDPutChar.c
//
//      Draws an ASCII character at the specified (x,y) address and color
//
//            Inputs:                 c        =     character to be displayed
//                                    x        =     row address (0 .. 131)
//                                    y        =     column address (0 .. 131)
//                                    size     =     font pitch (SMALL, MEDIUM, LARGE)
//                                   fcolor    =     12-bit foreground color value       rrrrggggbbbb
//                                   bcolor   =     12-bit background color value        rrrrggggbbbb
//
//            Returns:     nothing
//
//   Notes:   Here's an example to display "E" at address (20,20)
//
//                               LCDPutChar('E', 20, 20, MEDIUM, WHITE, BLACK);
//
//                                                    (27,20)              (27,27)
//                                                       |                    |
//                                                       |                    |
//                                                  ^    V                    V
//                                                  : _ # #      #   #   # # #   0x7F
//                                                  : _ _ #      #   _   _ _ #   0x31
//                                                  : _ _ #      #   _   # _ _   0x34
//                                                  x _ _ #      #   #   # _ _   0x3C
//                                                  : _ _ #      #   _   # _ _   0x34
//                                                  : _ _ #      #   _   _ _ #   0x31
//                                                  : _ # #      #   #   # # #   0x7F
//                                                  : _ _ _      _   _   _ _ _   0x00
//                                                       ^                    ^
//                                                       |                    |
//                                                       |                    |
//                                                  (20,20)               (20,27)
//
//                                                       ------y----------->
//
//
//                The most efficient way to display a character is to make use of the "wrap-around" feature
//                of the Epson S1D16G00 LCD controller chip.
//
//                Assume that we position the character at (20, 20) that's a (row, col) specification.
//                With the row and column address set commands, you can specify an 8x8 box for the SMALL and MEDIUM
//                characters or a 16x8 box for the LARGE characters.
//
//                         WriteSpiCommand(PASET);           // set the row drawing limits
//                         WriteSpiData(20);                 //
//                         WriteSpiData(27);                 // limit rows to (20, 27)
//
//                         WriteSpiCommand(CASET);           // set the column drawing limits
//                         WriteSpiData(20);                 //
//                         WriteSpiData(27);                 // limit columns to (20,27)
//
//                When the algorithm completes col 27, the column address wraps back to 20
//                At the same time, the row address increases by one (this is done by the controller)
//
//                We walk through each row, two pixels at a time. The purpose is to create three
//                data bytes representing these two pixels in the following format
//
//                         Data for pixel 0: RRRRGGGGBBBB
//                         Data for Pixel 1: RRRRGGGGBBBB
//
//                         WriteSpiCommand(RAMWR);           // start a memory write (96 data bytes to follow)
//
//                         WriteSpiData(RRRRGGGG);           // first pixel, red and green data
//                         WriteSpiData(BBBBRRRR);           // first pixel, blue data; second pixel, red data
//                         WriteSpiData(GGGGBBBB);           // second pixel, green and blue data
//                                  :
//       and so on until all pixels displayed!
//                                  :
//                         WriteSpiCommand(NOP);             // this will terminate the RAMWR command
//
//
//       Author: James P Lynch      August 30, 2007
// *****************************************************************************
void LCDPutChar(char c, int x, int y, int size, int fColor, int bColor) {

        extern const unsigned char FONT6x8[97][8];
        extern const unsigned char FONT8x8[97][8];
        extern const unsigned char FONT8x16[97][16];

        int                                         i,j;
        unsigned   int            nCols;
        unsigned   int            nRows;
        unsigned   int            nBytes;
        unsigned   char           PixelRow;
        unsigned   char           Mask;
        unsigned   int            Word0;
        unsigned   int            Word1;
        unsigned   char           *pFont;
        unsigned   char           *pChar;
        unsigned   char           *FontTable[] = {(unsigned char *)FONT6x8, (unsigned char *)FONT8x8,
                                                   (unsigned char *)FONT8x16};

        // get pointer to the beginning of the selected font table
        pFont = (unsigned char *)FontTable[size];

        // get the nColumns, nRows and nBytes
        nCols = *pFont;
        nRows = *(pFont + 1);
        nBytes = *(pFont + 2);

        // get pointer to the last byte of the desired character
        pChar = pFont + (nBytes * (c - 0x1F)) + nBytes - 1;

        // Row address set (command 0x2B)
        WriteSpiCommand(PASET);
        WriteSpiData(x);
        WriteSpiData(x + nRows - 1);

        // Column address set (command 0x2A)
        WriteSpiCommand(CASET);
        WriteSpiData(y);
        WriteSpiData(y + nCols - 1);
        // WRITE MEMORY
        WriteSpiCommand(RAMWR);

        // loop on each row, working backwards from the bottom to the top
        for (i = nRows - 1; i >= 0; i--) {

                // copy pixel row from font table and then decrement row
                PixelRow = *pChar--;

                // loop on each pixel in the row (left to right)
                // Note: we do two pixels each loop
                Mask = 0x80;
                for (j = 0; j < nCols; j += 2) {

                         // if pixel bit set, use foreground color; else use the background color
                         // now get the pixel color for two successive pixels
                         if ((PixelRow & Mask) == 0)
                                  Word0 = bColor;
                         else
                                  Word0 = fColor;
                         Mask = Mask >> 1;
                         if ((PixelRow & Mask) == 0)
                                  Word1 = bColor;
                         else
                                  Word1 = fColor;
                         Mask = Mask >> 1;

                         // use this information to output three data bytes
                         WriteSpiData((Word0 >> 4) & 0xFF);
                         WriteSpiData(((Word0 & 0xF) << 4) | ((Word1 >> 8) & 0xF));
                         WriteSpiData(Word1 & 0xFF);
                 }
        }
        // terminate the Write Memory command
        WriteSpiCommand(NOP);
}


// *************************************************************************************************
//                        LCDPutStr.c
//
//     Draws a null-terminates character string at the specified (x,y) address, size and color
//
//          Inputs:          pString =   pointer to character string to be displayed
//                           x       =   row address (0 .. 131)
//                           y       =   column address (0 .. 131)
//                           Size    =   font pitch (SMALL, MEDIUM, LARGE)
//                          fColor    =   12-bit foreground color value    rrrrggggbbbb
//                          bColor    =   12-bit background color value    rrrrggggbbbb
//
//
//          Returns:   nothing
//
//    Notes: Here's an example to display "Hello World!" at address (20,20)
//
//             LCDPutChar("Hello World!", 20, 20, LARGE, WHITE, BLACK);
//
//
//       Author: James P Lynch      August 30, 2007
// *************************************************************************************************
void LCDPutStr(char *pString, int x, int y, int Size, int fColor, int bColor) {

        // loop until null-terminator is seen
	while(*pString != 0x00){

	        // draw the character
                LCDPutChar(*pString++, x, y, Size, fColor, bColor);

                // advance the y position
                if (Size == SMALL)
                         y = y + 6;
                else if (Size == MEDIUM)
                         y = y + 8;
                else
                         y = y + 8;

                // bail out if y exceeds 131
                if (y > 131) break;
        }
	
	return;
	}

int main(void){

	int j, TempColor[11] = { WHITE, BLACK, RED, GREEN, BLUE, CYAN, MAGENTA,
                                             YELLOW, BROWN, ORANGE, PINK };

	clock_setup();
	tim_setup();
	InitLcd();

	// clear the screen
	LCDClearScreen();



	// ***************************************************************
	// * color test - show boxes of different colors
	// ***************************************************************

	for (j = 0; j < 11; j++) {

	       // draw a filled box
	       LCDSetRect(120, 10, 25, 120, FILL, TempColor[j]);

	       // wait a bit
	       udelay(2000);
	}
	
	LCDClearScreen();

	LCDPutStr("stm32f4", 60, 5, SMALL, WHITE, BLACK);
	LCDPutStr("nokia lcd", 40, 5, MEDIUM, ORANGE, BLACK);
	LCDPutStr("discovery-f4", 20, 5, LARGE, PINK, BLACK);	
	while (1){

	}

	return 0;
}
